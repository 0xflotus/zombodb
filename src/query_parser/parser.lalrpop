use std::str::FromStr;
use crate::query_parser::ast::*;

grammar;

match {
    // top precedence tokens
    ":" => CONTAINS,
    "=" => EQ,
    ">" => GT,
    "<" => LT,
    ">=" => GTE,
    "<=" => LTE,
    "<>" => NE,
    "!=" => DOES_NOT_CONTAIN,
    ":~" => REGEX,
    ":@" => MORE_LIKE_THIS,
    ":@~" => FUZZY_LIKE_THIS,

    "[" => O_BRACKET,
    "]" => C_BRACKET,

    "(" => O_PAREN,
    ")" => C_PAREN,

    "w/" => WITHIN,
    "wo/" => WITHIN_ORDER,

    "," => COMMA,
    r#"[0-9]+"# => NUMBER,

} else {
    // lower precedence operator keyword tokens
    r#"(?i)not|[!]"# => NOT,
    r#"(?i)((with|%)\s*)+"# => WITH,
    r#"(?i)((and|&)\s*)+"# => AND,
    r#"(?i)((or|,)\s*)+"# => OR,

    r#"(?i)null"# => NULL,

    r#"(?i)/to/"# => TO,
} else {
    // a field name looks a lot like a "simple value", so it needs to be defined
    // with a higher matching precedence
    r#"([a-z0-9_]+(\\.[a-z0-9_]+)*)+"# => FIELD_NAME,
} else {
    // even lower precedence values
    r#"(([[:word:]]|(\\.))+\.?)+"# => UNQUOTED_VALUE,
    r#"'(?:\\.|[^'\\])*'"# => QUOTED_VALUE,
    r#""(?:\\.|[^"\\])*""# => DOUBLE_QUOTED_VALUE,
    r#"\[\[[^\]]*\]\]"# => UNPARSED_ARRAY,
}

pub Expr: Box<Expr<'input>> = {
    <l:Expr> OrOp <r:BinaryOperand> => Box::new(Expr::Or(l, r)),
    BinaryOperand,
};

OrOp: Opcode = {
    OR => Opcode::Or,
    COMMA => Opcode::Or,
};

BinaryOperand: Box<Expr<'input>> = {
    <l:BinaryOperand> AndOp <r:WithOperand> => Box::new(Expr::And(l, r)),
    WithOperand,
};

AndOp: Opcode = {
    AND => Opcode::And,
    NOT => Opcode::AndNot,
};

WithOperand: Box<Expr<'input>> = {
    <l:WithOperand> WithOp <r:UnaryOperand> => Box::new(Expr::With(l, r)),
    UnaryOperand
};

WithOp: Opcode = {
    WITH => Opcode::With,
}

UnaryOperand: Box<Expr<'input>> = {
    <op:UnaryOp> <r:Comparison> => {
        match op {
            Opcode::Not => Box::new(Expr::Not(r)),
            _ => panic!("{:?} is not a Unary operation", op)
        }
    },
    Comparison,
};

UnaryOp: Opcode = {
    NOT => Opcode::Not,
};

Comparison: Box<Expr<'input>> = {
    FIELD_NAME ComparisonOp Term => Box::new(Expr::Cmp(<>)),
    Term
};

ComparisonOp: ComparisonOpcode = {
    CONTAINS => ComparisonOpcode::Contains,
    EQ => ComparisonOpcode::Eq,
    GT => ComparisonOpcode::Gt,
    LT => ComparisonOpcode::Lt,
    GTE => ComparisonOpcode::Gte,
    LTE => ComparisonOpcode::Lte,
    NE => ComparisonOpcode::Ne,
    DOES_NOT_CONTAIN => ComparisonOpcode::DoesNotContain,
    REGEX => ComparisonOpcode::Regex,
    MORE_LIKE_THIS => ComparisonOpcode::MoreLikeThis,
    FUZZY_LIKE_THIS => ComparisonOpcode::FuzzyLikeThis,
};

Term: Box<Expr<'input>> = {
    StringExpr => Box::new(<>),
    O_BRACKET <v:(String COMMA?)*> C_BRACKET => Box::new(Expr::ParsedArray(v)),
    UNPARSED_ARRAY => Box::new(Expr::UnparsedArray(<>)),
    <start:String> TO <end:String> => Box::new(Expr::Range(start, end)),
    ProximityChain => <>,
    O_PAREN <Expr> C_PAREN
};

ProximityChain: Box<Expr<'input>> = {
    <mut chain:(ProximityPart)+> <final_word: String> => {
        chain.push(ProximityPart {
            word: final_word,
            distance: 0,
            in_order: true
        });
        Box::new(Expr::ProximityChain(chain))
    },
}

ProximityPart: ProximityPart<'input> = {
    <word:String> WITHIN <distance:NUMBER> => ProximityPart { word, distance: u32::from_str(distance).unwrap(), in_order: false },
    <word:String> WITHIN_ORDER <distance:NUMBER> => ProximityPart { word, distance: u32::from_str(distance).unwrap(), in_order: true },
};

StringExpr: Expr<'input> = {
    NULL => Expr::Null,
    String => Expr::String(<>)
}

String: &'input str = {
    NUMBER => <>,
    FIELD_NAME => <>,
    UNQUOTED_VALUE => <>,
    QUOTED_VALUE => {
        let s = <>;
        let s = &s[1..s.len()-1];
        s
    },
    DOUBLE_QUOTED_VALUE => {
        let s = <>;
        let s = &s[1..s.len()-1];
        s
    },
};