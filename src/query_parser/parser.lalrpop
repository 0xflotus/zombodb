use std::str::FromStr;
use crate::query_parser::ast::*;

grammar;

match {
    // top precedence tokens
    ":" => CONTAINS,
    "=" => EQ,
    ">" => GT,
    "<" => LT,
    ">=" => GTE,
    "<=" => LTE,
    "<>" => NE,
    "!=" => DOES_NOT_CONTAIN,
    ":~" => REGEX,
    ":@" => MORE_LIKE_THIS,
    ":@~" => FUZZY_LIKE_THIS,

    "[" => O_BRACKET,
    "]" => C_BRACKET,

    "(" => O_PAREN,
    ")" => C_PAREN,

    "w/" => WITHIN,
    "wo/" => WITHIN_ORDER,

    r#"[0-9]+"# => NUMBER,
    r#"[0-9]+\.[0-9]+"# => FLOAT,

} else {
    // lower precedence operator keyword tokens
    r"(?i)not" => NOT,
    r"(?i)with" => WITH,
    r"(?i)and" => AND,
    r"(?i)or" => OR,

    "!" => EXCLAMATION,
    "%" => PERCENT,
    "&" => AMPERSAND,
    "," => COMMA,

    "^" => CARET,

    r#"(?i)null"# => NULL,

    r#"(?i)/to/"# => TO,
} else {
    // a field name looks a lot like a "simple value", so it needs to be defined
    // with a higher matching precedence
    r#"([a-z0-9_]+(\.[a-z0-9_]+)*)+"# => FIELD_NAME,
} else {
    // even lower precedence values
    r#"(([[:word:]]|(\\.))+\.?)+"# => UNQUOTED_VALUE,
    r#"'(?:\\.|[^'\\])*'"# => QUOTED_VALUE,
    r#""(?:\\.|[^"\\])*""# => DOUBLE_QUOTED_VALUE,
    r#"\[\[[^\]]*\]\]"# => UNPARSED_ARRAY,
}

pub Expr: Box<Expr<'input>> = {
    <l:Expr> OrOp <r:BinaryOperand> => Box::new(Expr::Or(l, r)),
    BinaryOperand,
};

OrOp: Opcode = {
    OR => Opcode::Or,
    COMMA => Opcode::Or,
};

BinaryOperand: Box<Expr<'input>> = {
    <l:BinaryOperand> <op:AndOp> <r:WithOperand> => {
        match op {
            Opcode::And => Box::new(Expr::And(l, r)),
            Opcode::AndNot => Box::new(Expr::And(l, Box::new(Expr::Not(r)))),
            _ => panic!("{:?} is not an AndOp", op)
        }
    },
    WithOperand,
};

AndOp: Opcode = {
    NOT => Opcode::AndNot,
    EXCLAMATION => Opcode::AndNot,
    AND => Opcode::And,
    AMPERSAND => Opcode::And,
};

WithOperand: Box<Expr<'input>> = {
    <l:WithOperand> WithOp <r:ProximityOperand> => Box::new(Expr::With(l, r)),
    ProximityOperand
};

WithOp: Opcode = {
    WITH => Opcode::With,
    PERCENT => Opcode::With,
}

ProximityOperand: Box<Expr<'input>> = {
    <mut parts:ProximityPart+> <last:Term> => {
        let mut words = Vec::new();
        last.extract_prox_terms(&mut words);
        parts.push(ProximityPart {
            words,
            distance:0,
            in_order:false
        });

        Box::new(Expr::ProximityChain(parts))
    },
    UnaryOperand
};

ProximityPart: ProximityPart<'input> = {
    <l:Term> WITHIN <distance:NUMBER> => {
        let mut words = Vec::new();
        l.extract_prox_terms(&mut words);
        ProximityPart {
            words,
            distance: u32::from_str(distance).unwrap(),
            in_order:false
        }
    },
    <l:Term> WITHIN_ORDER <distance:NUMBER> => {
        let mut words = Vec::new();
        l.extract_prox_terms(&mut words);
        ProximityPart {
            words,
            distance: u32::from_str(distance).unwrap(),
            in_order:true
        }
    }
};

UnaryOperand: Box<Expr<'input>> = {
    NotOp <t:UnaryOperand> => Box::new(Expr::Not(t)),
    Comparison,
};

NotOp: Opcode = {
    NOT => Opcode::Not,
    EXCLAMATION => Opcode::Not
};

Comparison: Box<Expr<'input>> = {
    FIELD_NAME ComparisonOp Term => Box::new(Expr::from_opcode(<>)),
    Term
};

ComparisonOp: ComparisonOpcode = {
    CONTAINS => ComparisonOpcode::Contains,
    EQ => ComparisonOpcode::Eq,
    GT => ComparisonOpcode::Gt,
    LT => ComparisonOpcode::Lt,
    GTE => ComparisonOpcode::Gte,
    LTE => ComparisonOpcode::Lte,
    NE => ComparisonOpcode::Ne,
    DOES_NOT_CONTAIN => ComparisonOpcode::DoesNotContain,
    REGEX => ComparisonOpcode::Regex,
    MORE_LIKE_THIS => ComparisonOpcode::MoreLikeThis,
    FUZZY_LIKE_THIS => ComparisonOpcode::FuzzyLikeThis,
};

Term: Box<Expr<'input>> = {
    StringExpr => Box::new(<>),
    O_BRACKET <v:(<String> COMMA?)*> C_BRACKET <b:Boost?> => Box::new(Expr::ParsedArray(v, b)),
    <a:UNPARSED_ARRAY> <b:Boost?> => Box::new(Expr::UnparsedArray(a, b)),
    <start:String> TO <end:String> <b:Boost?> => Box::new(Expr::Range(start, end, b)),
    O_PAREN <Expr> C_PAREN,
};

StringExpr: Expr<'input> = {
    NULL => Expr::Null,
    <s:String> <b:Boost?> => Expr::String(s, b)
};

Boost: f32 = {
    CARET <FLOAT> => f32::from_str(<>).unwrap(),
    CARET <NUMBER> => f32::from_str(<>).unwrap(),
};

String: &'input str = {
    NUMBER => <>,
    FLOAT => <>,
    FIELD_NAME => <>,
    UNQUOTED_VALUE => <>,
    QUOTED_VALUE => {
        let s = <>;
        let s = &s[1..s.len()-1];
        s
    },
    DOUBLE_QUOTED_VALUE => {
        let s = <>;
        let s = &s[1..s.len()-1];
        s
    },
};