use std::str::FromStr;
use crate::query_parser::ast::*;

grammar;

match {
    // top precedence tokens
    ":" => CONTAINS,
    "=" => EQ,
    ">" => GT,
    "<" => LT,
    ">=" => GTE,
    "<=" => LTE,
    "<>" => NE,
    "!=" => DOES_NOT_CONTAIN,
    ":~" => REGEX,
    ":@" => MORE_LIKE_THIS,
    ":@!" => FUZZY_LIKE_THIS,

    "[" => O_BRACKET,
    "]" => C_BRACKET,

    "(" => O_PAREN,
    ")" => C_PAREN,

    "w/" => WITHIN,
    "wo/" => WITHIN_ORDER,

    "," => COMMA,
    r#"[0-9]+"# => NUMBER,

} else {
    // lower precedence operator keyword tokens
    r#"(?i)(not|\\!)+"# => NOT,
    r#"(?i)(with|%)+"# => WITH,
    r#"(?i)(and|&)+"# => AND,
    r#"(?i)(or|,)+"# => OR,

    r#"(?i)true"# => TRUE,
    r#"(?i)false"# => FALSE,
    r#"(?i)null"# => NULL,

    r#"(?i)/to/"# => TO,
} else {
    // a field name looks a lot like a "simple value", so it needs to be defined
    // with a higher matching precedence
    r#"([a-z0-9_]+(\\.[a-z0-9_]+)*)+"# => FIELD_NAME,
} else {
    // even lower precedence values
    r#"(([[:word:]]|(\\.))+\.?)+"# => SIMPLE_VALUE,
    r#"'(?:\\.|[^'\\])*'"# => QUOTED_VALUE,
    r#""(?:\\.|[^"\\])*""# => DOUBLE_QUOTED_VALUE,
    r#"\[\[[^\]]*\]\]"# => UNPARSED_ARRAY,
}

pub Expr: Box<Expr<'input>> = {
    Expr OrOp BinaryOperand => Box::new(Expr::Op(<>)),
    BinaryOperand,
};

OrOp: Opcode = {
    OR => Opcode::Or,
    COMMA => Opcode::Or,
};

BinaryOperand: Box<Expr<'input>> = {
    BinaryOperand AndOp WithOperand => Box::new(Expr::Op(<>)),
    WithOperand,
};

AndOp: Opcode = {
    AND => Opcode::And,
    NOT => Opcode::AndNot,
};

WithOperand: Box<Expr<'input>> = {
    WithOperand WithOp UnaryOperand => Box::new(Expr::Op(<>)),
    UnaryOperand
};

WithOp: Opcode = {
    WITH => Opcode::With,
}

UnaryOperand: Box<Expr<'input>> = {
    UnaryOp Comparison => Box::new(Expr::UnaryOp(<>)),
    Comparison,
};

UnaryOp: Opcode = {
    NOT => Opcode::Not,
};

Comparison: Box<Expr<'input>> = {
    FIELD_NAME ComparisonOp Term => Box::new(Expr::Cmp(<>)),
    Term
};

ComparisonOp: ComparisonOpcode = {
    CONTAINS => ComparisonOpcode::Contains,
    EQ => ComparisonOpcode::Eq,
    GT => ComparisonOpcode::Gt,
    LT => ComparisonOpcode::Lt,
    GTE => ComparisonOpcode::Gte,
    LTE => ComparisonOpcode::Lte,
    NE => ComparisonOpcode::Ne,
    DOES_NOT_CONTAIN => ComparisonOpcode::DoesNotContain,
    REGEX => ComparisonOpcode::Regex,
    MORE_LIKE_THIS => ComparisonOpcode::MoreLikeThis,
    FUZZY_LIKE_THIS => ComparisonOpcode::FuzzyLikeThis,
};

Term: Box<Expr<'input>> = {
    Value => <>,
    O_BRACKET <v:(Value COMMA?)*> C_BRACKET => Box::new(Expr::ParsedArray(v)),
    UNPARSED_ARRAY => Box::new(Expr::UnparsedArray(<>)),
    <start:Value> TO <end:Value> => Box::new(Expr::Range(start, end)),
    ProximityChain => <>,
    O_PAREN <Expr> C_PAREN
};

ProximityChain: Box<Expr<'input>> = {
    <mut chain:(ProximityPart)+> <final_word: StringValue> => {
        chain.push(ProximityPart {
            word: final_word,
            distance: 0,
            in_order: true
        });
        Box::new(Expr::ProximityChain(chain))
    },
}

ProximityPart: ProximityPart<'input> = {
    <word:StringValue> WITHIN <distance:NUMBER> => ProximityPart { word, distance: u32::from_str(distance).unwrap(), in_order: false },
    <word:StringValue> WITHIN_ORDER <distance:NUMBER> => ProximityPart { word, distance: u32::from_str(distance).unwrap(), in_order: true },
};


Value: Box<Expr<'input>> = {
    NUMBER => Box::new(Expr::Value(<>)),
    SIMPLE_VALUE => Box::new(Expr::Value(<>)),
    FIELD_NAME => Box::new(Expr::Value(<>)),
    QUOTED_VALUE => {
        let s = <>;
        let s = &s[1..s.len()-1];
        Box::new(Expr::Value(s))
    },
    DOUBLE_QUOTED_VALUE => {
        let s = <>;
        let s = &s[1..s.len()-1];
        Box::new(Expr::Value(s))
    },
    TRUE => Box::new(Expr::Boolean(true)),
    FALSE => Box::new(Expr::Boolean(false)),
    NULL => Box::new(Expr::Null),
};

StringValue: &'input str = {
    NUMBER => <>,
    SIMPLE_VALUE => <>,
    FIELD_NAME => <>,
    QUOTED_VALUE => {
        let s = <>;
        let s = &s[1..s.len()-1];
        s
    },
    DOUBLE_QUOTED_VALUE => {
        let s = <>;
        let s = &s[1..s.len()-1];
        s
    },
    TRUE => <>,
    FALSE => <>,
    NULL => <>
};